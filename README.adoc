= lread.test-doc-blocks
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:toc: macro

// Exercise our :apply option by skipping all code blocks by default for this doc
//#:test-doc-blocks{:skip true :apply :all-next}

image:https://github.com/lread/test-doc-blocks/workflows/Test/badge.svg[Test]

Generate runnable tests from code blocks in Asciidoctor and CommonMark files.

[CAUTION]
====
Example code in docs, while likely not malicious, could be illustrating, for example, how to wipe a drive. +
So, do be deliberate and careful about what docs you run through test-doc-blocks.
====

toc::[]

== Status

Initial concept. Currently being used to test doc blocks in rewrite-cljc.

* Alpha, this might not be a good general idea, but might work well for some projects.
* No release to clojars yet.
* Feedback welcome.

== Rationale
I wanted to make sure the code examples I provided in rewrite-cljc documentation do not mislead and would function as expected for those who dared to try them.

Test-doc-blocks might (or might not, see link:#limitations[limitations], and link:#other-options[other options]) be of interest for your Clojure project too.

If your example code blocks are REPL style:

//#:test-doc-blocks{:skip false}
[source,clojure]
----
user=> (* 6 7)
42
----

Or editor style:

//#:test-doc-blocks{:skip false}
[source,clojure]
----
(* 6 7)
;; => 42
----

And don't rely on any special unspecified setup, then test-doc-blocks might work for your project too.

== Immediate TODOS

* allow metadata to be attached to generated tests which can then in turn be used by test runners
* turf unused script helpers I pasted in from rewrite-cljc

Maybe:

* bring in battle tested parsers for docs? asciidoctorj, flexmark
* might be nice to offer to validate edn snippits are readable?
* integration test is super brittle but that's ok for now
* consider supporting expressing stdout and stderr as they might naturally be output, they would still be compared as single blocks, but this might better represent a visual output flow.
** stderr line1
** stdout line1
** stderr line2
** etc..
* Consider supporting continuations on expectations for readability? Maybe something like?
+
[source,clojure]
----
;; => {:a 1
;      :b 2
;      :c 3}
----

== Usage

Add an alias to your `deps.edn`:

[source,clojure]
----
    :test-doc-blocks {:extra-deps {lread/test-doc-blocks {:git "tbd"
                                                          :sha "tbd"}}
                      :ns-default lread.test-doc-blocks}
----

Then the most basic usage is:

[source,shell]
----
clojure -X:test-doc-blocks gen-tests
----

This will generate Clojure tests for code blocks in your `README.md` to `target/test-doc-blocks/test`.
Any existing tests under `target/test-doc-blocks` will be replaced.

You can then run the generated tests with the test runner of your choosing.
Our link:deps.edn[deps.edn] has example aliases:

* `:isolated/cljs-test-runner` - runs generated tests under ClojureScript using https://github.com/Olical/cljs-test-runner[cljs-test-runner] +
Invoke for this project via: `clj -M:isolated/cljs-test-runner`
* `:isolated/kaocha` - runs generated tests under Clojure using https://github.com/lambdaisland/kaocha[kaocha] +
Invoke for this project via: `clj -M:isolated/kaoacha generated`. Note also kaocha link:test.edn[test.edn] config.
* `:isolated/clj-test-runner` - runs generated tests under Clojure using https://github.com/cognitect-labs/test-runner[Cognitect test-runner] +
Invoke for this project via: `clj -M:isolated/clj-test-runner`

When tests are run, the test-doc-blocks runtime will look for assertions in editor style and REPL style format.
For example:

//#:test-doc-blocks{:skip false}
[source,clojure]
----
user=> (/ 714 17)
42
----

Will be evaluated as the assertion `(is (= 42 (/ 714 17)))`.

For more detailed examples and inline options, see

* link:doc/example.adoc[Asciidoctor example]
* link:doc/example.md[CommonMark example]

=== Command Line Options

==== :docs
The default file to generate tests for is README.md.

If you want to specify a different vector of files you can do so via `:docs`:

[source,shell]
----
clojure -X:test-doc-blocks gen-tests :docs '["README.adoc" "doc/example.adoc" "doc/example.md"]'
----

==== :target-root
The default directory to generate tests is `./target`.

You can override this via `:target-root`:

[source,shell]
----
clojure -X:test-doc-blocks gen-tests :target-root '"./someplace/else"'
----

Note that test-doc-blocks will delete and recreate `test-docs-block/test` dirs under the target root.
Keep that the location mind when figuring out where to point your test runner.

==== :platform
The platform governs what Clojure file types will be generated for tests.

Specify:

* `:clj` for Clojure, generates `.clj` files
* `:cljs` for ClojureScript, generates `.cljs` files
* `:cljc` for mixed, generates `.cljc` files

The default is `:cljc`.

Platform can be overridden for code blocks via inline options.

[#limitations]
== Limitations

Some current limitations that we might entertain addressing:

* I'm initially coming at this from a cljc project and that bias will show and might not be appropriate for your project.
* If your code block depends on some external setup, we've no way to express that.
* Test-doc-blocks will automatically handle inline `(require ...)` and `(import ...)` appearing in code blocks, but not in any complex expressions of these forms.
* Parsing adoc and md files is on the naive side but should handle most common cases.
If we've overlooked a common syntax, let us know.

Some limitations we have no current plans to address:

* Code blocks using `ns` or `in-ns` will not work with test-doc-blocks.
* It is possible to embed HTML into your docs.
If your code or headings are expressed in HTML, we won't find them.

[#other-options]
== Other Options

Here are other options and related projects that I am currently aware of:

* https://github.com/lambdaisland/kaocha[kaocha] - Koacha supports running cucumber tests.
It uses this cucumber tests for its own documentation.
A .feature document describes the feature and includes given, when, then scenarios that are both run and shown in documentation.
Gritty details can be hidden in step definitions.
* https://github.com/seancorfield/readme[readme] - Generates tests for code blocks found in .md files and then runs them.
* https://github.com/liquidz/testdoc[testdoc] - Tests code blocks in docstrings and external docs.
* https://github.com/sogaiu/alc.x-as-tests[alc.x-as-tests] - Runs code in `(comment ...)` blocks as tests.

== Development

=== Prerequisites

In addition to the https://clojure.org/guides/getting_started[Clojure CLI], you will need to install https://github.com/borkdude/babashka[babashka] to run scripts.

The example ClojureScript test runner does make use of https://nodejs.org[Node.js]

=== Tests

==== Unit
[source,shell]
----
clojure -M:kaocha unit
----

==== Integration
Run integration test via:
[source,shell]
----
clojure -M:koacha integration
----
This will generate tests for README and example docs and then diff against a previously manually verified test run.
The previously verified test run is stored under `test-resources/expected`.

On failure careful manual inspection is recommended.
When you are happy with current behaviour of generation of tests:

[source,shell]
----
bb script/gen_local_tests.clj regen-expected
----

==== Generated

Generate tests for local docs via:
[source,shell]
----
bb script/gen_local_tests.clj
----

Run generated tests under Clojure via:
[source,shell]
----
clojure -M:isolated/kaocha generated
----

And under ClojureScript via:
[source,shell]
----
clojure -M:isolated/cljs-test-runner
----

==== Continuous Integration

To run what CI runs:
[source,shell]
----
bb script/ci_tests.clj
----

=== Linting
We use clj-kondo to lint project source and fail the build when linting fails.

To run linting as the CI server does:

[source,shll]
----
bb script/lint.clj
----

=== Release

TODO: fill in the blanks.

== Versioning

rewrite-cljc versioning scheme is: `major`.`minor`.`patch`-`test-qualifier`

* `major` increments when the API has been broken - something, as a rule, we'd like to avoid.
* `minor` increments to convey significant new features have been added.
* `patch` indicates bug fixes - it is the number of commits since `major`.`minor`.
* `test-qualifier` is absent for stable releases. Can be `alpha`, `beta`, `rc1`, etc.

== People

=== Contributors

* @seancorfield - idea is based on Sean's https://github.com/seancorfield/readme[readme] project.
* Helpful feedback and ideas from:
** @borkdude
** @sogaiu
** @dominicin
** @pez
** @uochan

=== Current Maintainers

* @lread

== License

Copyright Â© 2020 Lee Read, all rights reserved.

Distributed under the EPL License, same as Clojure. See LICENSE.

Concept based on @seancorfield's https://github.com/seancorfield/readme[readme] which is distributed under EPL v1.0 or later.
